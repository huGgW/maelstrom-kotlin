# Maelstrom 프로토콜 문서

## 개요

Maelstrom은 분산 시스템을 시뮬레이션하고 테스트하기 위한 도구입니다. 이 문서는 Maelstrom과 호환되는 노드를 구현하기 위한 통신 프로토콜을 설명합니다.

## 기본 통신 방식

Maelstrom 노드는 다음과 같은 방식으로 통신합니다:

- **STDIN**: 메시지 수신
- **STDOUT**: 메시지 송신
- **STDERR**: 디버깅 출력 (Maelstrom이 디스크에 로깅)

**중요**: 노드는 STDOUT에 메시지가 아닌 내용을 출력해서는 안 됩니다.

## 노드와 네트워크 구조

### 노드 유형

Maelstrom 테스트는 분산 시스템을 시뮬레이션하기 위해 여러 *노드*를 실행하며, 네트워크가 이들 간의 *메시지*를 라우팅합니다.

#### 서버 노드
- **식별자**: `n1`, `n2`, `n3` 등
- **역할**: 사용자가 Maelstrom에 전달하는 바이너리의 인스턴스
- **기능**: 분산 알고리즘 구현 (예: 키-값 저장소)
- **동작**: 클라이언트 요청을 받아 응답을 전송하는 서버 역할

#### 클라이언트 노드
- **식별자**: `c1`, `c2`, `c3` 등
- **역할**: Maelstrom의 내부 클라이언트
- **동작**: 서버에 요청을 보내고 간단한 비동기 RPC 프로토콜을 통해 응답을 수신

### 네트워크 특성
- 각 노드는 고유한 문자열 식별자를 가짐
- 네트워크가 노드 간 메시지 라우팅을 담당
- 메시지 라우팅에 식별자 사용

## 메시지 구조

### 기본 메시지 형식

STDIN과 STDOUT의 모든 메시지는 개행문자(`\n`)로 구분된 JSON 객체입니다.

```json
{
  "src":  "이 메시지를 보낸 노드를 식별하는 문자열",
  "dest": "이 메시지를 받을 노드를 식별하는 문자열",
  "body": "메시지의 페이로드인 객체"
}
```

### 메시지 바디 구조

Maelstrom 클라이언트와 교환되는 RPC 메시지의 바디는 다음과 같은 예약된 키를 가집니다:

```json
{
  "type":        "(필수) 메시지 타입을 식별하는 문자열",
  "msg_id":      "(선택) 고유한 정수 식별자",
  "in_reply_to": "(선택) 요청/응답용, 요청의 msg_id"
}
```

#### 메시지 ID 규칙
- 메시지 ID는 송신 노드에서 고유해야 합니다
- 각 노드는 단조 증가하는 정수를 메시지 ID 소스로 사용할 수 있습니다

#### 메시지 타입별 추가 키
각 메시지는 타입에 따라 추가 키를 가집니다. 예를 들어:

**읽기 요청** (`lin_kv` 워크로드에서 키 `3`의 현재 값을 요청):
```json
{
  "type": "read",
  "msg_id": 123,
  "key": 3
}
```

**읽기 응답** (현재 값이 `4`임을 나타냄):
```json
{
  "type": "read_ok",
  "msg_id": 56,
  "in_reply_to": 123,
  "value": 4
}
```

### 서버 간 메시지
서버 노드 간에 교환되는 메시지는 원하는 어떤 `body` 구조든 가질 수 있습니다:
- 요청-응답 방식에 제한되지 않음
- 원하는 메시지 의미론을 자유롭게 구현 가능
- 위에서 설명한 바디 형식을 사용하면 Maelstrom이 유용한 시각화와 통계를 생성할 수 있음

## 초기화 과정

### 초기화 메시지
테스트 시작 시 Maelstrom은 각 노드에 단일 `init` 메시지를 발행합니다:

```json
{
  "type":     "init",
  "msg_id":   1,
  "node_id":  "n3",
  "node_ids": ["n1", "n2", "n3"]
}
```

#### 필드 설명
- **`node_id`**: 이 메시지를 받는 노드의 ID (여기서는 "n3")
- **`node_ids`**: 클러스터의 모든 노드 목록 (수신자 포함)

#### 노드의 책임
- 노드는 이 ID를 기억해야 함
- 보내는 모든 메시지의 `src`에 이 ID를 포함해야 함
- 모든 노드는 동일한 목록을 받음 (필요시 순서 활용 가능)

### 초기화 응답
`init` 메시지에 대한 응답으로 각 노드는 `init_ok` 타입의 메시지로 응답해야 합니다:

```json
{
  "type":        "init_ok",
  "in_reply_to": 1
}
```

## 에러 처리

### 에러 메시지 구조
Maelstrom RPC 요청에 대한 응답으로 노드는 *에러* 메시지로 응답할 수 있습니다:

```json
{
 "type":        "error",
 "in_reply_to": 5,
 "code":        11,
 "text":        "Node n5 is waiting for quorum and cannot service requests yet"
}
```

#### 필드 설명
- **`type`**: 에러 바디의 타입은 항상 `"error"`
- **`in_reply_to`**: 모든 RPC 응답과 마찬가지로 이 에러를 유발한 요청의 `msg_id`
- **`code`**: 발생한 에러 타입을 나타내는 정수
- **`text`**: 선택적인 자유 형식 문자열 (설명적 메시지 포함 가능)

#### 추가 필드
에러 바디에 다른 키를 포함할 수 있습니다:
- Maelstrom이 히스토리의 일부로 보존
- 자체 분석에 도움이 될 수 있음

### 에러 타입

#### 확정적(Definite) vs 비확정적(Indefinite) 에러
- **확정적 에러**: 요청된 작업이 확실히 발생하지 않았고 앞으로도 발생하지 않을 것
- **비확정적 에러**: 작업이 발생했을 수도, 발생하지 않았을 수도, 나중에 발생할 수도 있음

#### 중요 원칙
- Maelstrom은 이 정보를 사용하여 히스토리를 올바르게 해석
- 비확정적 상황에서 확정적 에러를 반환하면 안 됨
- **의심스러울 때는 항상 비확정적이 안전**
- 사용자 정의 에러 코드는 항상 비확정적

### 에러 코드 체계

#### 코드 범위
- **0-999**: Maelstrom 전용 예약
- **1000 이상**: 사용자 정의 가능

#### 정의된 에러 코드

| 코드 | 상수명 | 설명 | 타입 |
|------|--------|------|------|
| 0 | TIMEOUT | 타임아웃 | 비확정적 |
| 10 | NOT_SUPPORTED | 지원되지 않음 | 확정적 |
| 11 | TEMPORARILY_UNAVAILABLE | 일시적으로 사용 불가 | 비확정적 |
| 12 | MALFORMED_REQUEST | 잘못된 형식의 요청 | 확정적 |
| 13 | CRASH | 크래시 | 비확정적 |
| 14 | ABORT | 중단 | 확정적 |
| 20 | KEY_DOES_NOT_EXIST | 키가 존재하지 않음 | 확정적 |
| 21 | KEY_ALREADY_EXISTS | 키가 이미 존재함 | 확정적 |
| 22 | PRECONDITION_FAILED | 전제 조건 실패 | 확정적 |
| 30 | TXN_CONFLICT | 트랜잭션 충돌 | 확정적 |

## RPC 통신 방식

### 비동기 RPC
- 요청-응답 패턴 기반
- `msg_id`와 `in_reply_to` 필드를 통한 요청-응답 매칭
- 비동기적으로 처리되어 높은 동시성 지원

### 메시지 흐름
1. 클라이언트가 고유한 `msg_id`를 가진 요청 전송
2. 서버가 요청을 처리
3. 서버가 `in_reply_to` 필드에 원래 요청의 `msg_id`를 포함한 응답 전송
4. 클라이언트가 `in_reply_to`를 통해 응답을 해당 요청에 매칭

### 서버 간 통신
- 서버 노드 간 메시지는 임의의 구조 가능
- RPC 패턴에 국한되지 않음
- 원하는 메시지 의미론 구현 가능
- Maelstrom 형식을 따르면 시각화 및 통계 지원

## 워크로드

### 워크로드 정의
워크로드는 분산 시스템의 의미론을 명시합니다:
- 수행되는 작업
- 클라이언트가 요청을 제출하는 방식
- 요청의 의미
- 예상되는 응답
- 발생할 수 있는 에러
- 히스토리의 안전성을 검사하는 방법

### 브로드캐스트 워크로드 예시
브로드캐스트 워크로드의 동작 방식:

1. **브로드캐스트**: 클라이언트가 임의의 서버에 `broadcast` 메시지 제출
2. **읽기**: `read` 요청으로 모든 브로드캐스트된 메시지의 집합 조회
3. **혼합 작업**: 히스토리 전반에 걸쳐 읽기와 브로드캐스트 작업을 혼합
4. **수렴**: 테스트 끝에 수렴 기간 제공
5. **최종 읽기**: 수렴 후 최종 읽기 수행
6. **검증**: 메시지가 적시에 브로드캐스트되었는지, 손실되지 않았는지 검사

### 메시지 타입과 필드
- 각 워크로드의 메시지 타입과 필드 의미는 `workloads.md`에 정의
- Maelstrom 소스 코드에서 `lein run doc` 명령으로 자동 생성된 참조 문서 확인 가능

## 구현 시 고려사항

### 필수 구현 요소
1. **초기화 처리**: `init` 메시지 처리 및 `init_ok` 응답
2. **메시지 라우팅**: 메시지 타입별 핸들러 등록 및 실행
3. **RPC 지원**: 요청-응답 매칭을 위한 메시지 ID 관리
4. **에러 처리**: 적절한 에러 코드와 메시지로 에러 응답
5. **JSON 처리**: 안정적인 JSON 직렬화/역직렬화

### 성능 고려사항
- 동시 메시지 처리를 위한 비동기 처리
- 메시지 ID 생성의 스레드 안전성
- 대기 중인 RPC 요청의 효율적인 관리

### 테스트 고려사항
- 다양한 메시지 타입에 대한 핸들러 테스트
- 에러 상황에 대한 적절한 응답 테스트
- RPC 요청-응답 매칭의 정확성 테스트
- 동시성 상황에서의 안정성 테스트

이 프로토콜을 따라 구현하면 Maelstrom과 호환되는 분산 시스템 노드를 만들 수 있으며, 다양한 분산 시스템 알고리즘을 실험하고 테스트할 수 있습니다.